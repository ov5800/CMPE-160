library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_serial_adder is
end entity tb_serial_adder;

architecture behv of tb_serial_adder is

component serial_adder is
	port (
		signal in_a : in std_logic_vector( 3 downto 0 );
		signal control : in std_logic_vector( 1 downto 0 );
		signal clk : in std_logic;
		signal clear_dp : std_logic;
		signal in_b : in std_logic_vector( 3 downto 0 );

		signal sum : out std_logic_vector( 3 downto 0 );
		signal carry : out std_logic
	);
end component serial_adder;

signal in_a : std_logic_vector( 3 downto 0 );
signal control : std_logic_vector( 1 downto 0 );
signal clk : std_logic;
signal clear_dp : std_logic;
signal in_b : std_logic_vector( 3 downto 0 );
signal sum : std_logic_vector( 3 downto 0 );
signal carry : std_logic;
constant clk_period : time := 100 ns;


Type test_vector is record
	in_a : std_logic_vector( 3 downto 0 );
	in_b : std_logic_vector( 3 downto 0 );
	sum : std_logic_vector( 3 downto 0 );
	carry : std_logic;
end record;


Type test_record_array is array ( natural range <> ) of test_vector;
	constant tests : test_record_array := (
		-- list of values
        (X"0", X"4", X"4", '0'), 
        (X"C", X"E", X"A", '1'), 
        (X"8", X"A", X"2", '1'),
        (X"F", X"F", X"E", '1'), 
        (X"F", X"1", X"0", '1'), 
        (X"A", X"5", X"2", '0'), 
        (X"8", X"7", X"F", '0'));

-- Helper function to print std_logic_vectors more easily
    function vec2str(vec: std_logic_vector) return string is
        variable stmp: string(vec'high+1 downto 1);
        variable counter : integer := 1;
    begin
        for i in vec'reverse_range loop
            stmp(counter) := std_logic'image(vec(i))(2); -- image returns '1' (with quotes)
            counter := counter + 1;
        end loop;
        return stmp;
    end vec2str;

begin

UUT : serial_adder
port map (
	-- internal signals
	in_a => in_a,
	in_b => in_b,
	control => control,
	clk => clk,
	clear_dp => clear_dp,
	sum => sum,
	carry => carry
);

clk_process : process
begin
	clk <= '0';
	wait for clk_period/2;
	clk <= '1';
	wait for clk_period/2;
end process;


process
begin
	for i in tests'range loop
		wait until rising_edge(clk);
			clear_dp <= '0';
		wait for 3*clk_period / 2;
			clear_dp <= '1';
			in_a <= tests(i).in_a;
			in_b <= tests(i).in_b;
			control <= "11";
		wait for clk_period;
			control <= "10";
		wait for clk_period * 4;
		assert tests(i).sum = sum 
			report "sum is wrong" severity ERROR;
		assert tests(i).carry = carry
			report "carry is wrong" severity ERROR;
	end loop;
	assert false
		report "shit might actually work" severity failure;
end process;
	
end architecture behv;